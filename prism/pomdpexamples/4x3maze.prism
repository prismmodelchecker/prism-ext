//pomdp of 4X3 95 maze
// 4X3.95.POMDP - Stuart Russell's 4x3 maze
pomdp

// observable variables
observables 
	x1
endobservables

module stuart_maze

	x1 : [0..6]; // observations
	x2 : [0..11]; // actual state

	// OBSERVATION 0 (left)- only go north, south or east
	
	//actual state 0
	[n] x1=0 & x2=0 -> 0.9:(x1'=0)&(x2'=0) + 0.1:(x1'=2)&(x2'=1) ;
	[s] x1=0 & x2=0 -> 0.8:(x1'=3)&(x2'=4) + 0.1:(x1'=0)&(x2'=0) + 0.1:(x1'=2)&(x2'=1) ; 
	[e] x1=0 & x2=0 -> 0.8:(x1'=2)&(x2'=1) + 0.1:(x1'=0)&(x2'=0) + 0.1:(x1'=3)&(x2'=4) ; 


	//actual state 5
	[n] x1=0 & x2=5 -> 0.8:(x1'=2)&(x2'=2) + 0.1:(x1'=0)&(x2'=5) + 0.1:(x1'=5)&(x2'=6)  ;
	[s] x1=0 & x2=5 -> 0.8:(x1'=2)&(x2'=9) + 0.1:(x1'=0)&(x2'=5) + 0.1:(x1'=5)&(x2'=6)  ;
	[e] x1=0 & x2=5 -> 0.8:(x1'=5)&(x2'=6) + 0.1:(x1'=2)&(x2'=2) + 0.1:(x1'=2)&(x2'=9) ; 
	
	
	//actual state 7
	[n] x1=0 & x2=7 -> 0.8:(x1'=3)&(x2'=4) + 0.1:(x1'=0)&(x2'=7) + 0.1:(x1'=2)&(x2'=8)  ;
	[s] x1=0 & x2=7 -> 0.9:(x1'=0)&(x2'=7) + 0.1:(x1'=2)&(x2'=8) ; 
	[e] x1=0 & x2=7 -> 0.8:(x1'=2)&(x2'=8) + 0.1:(x1'=0)&(x2'=7) + 0.1:(x1'=3)&(x2'=4) ; 
	

	// OBSERVATION 1 - only go north, south, or west
	
	//actual state 10
	[n] x1=1 & x2=10 -> 0.8:(x1'=5)&(x2'=6) + 0.1:(x1'=1)&(x2'=10) + 0.1:(x1'=2)&(x2'=9)  ;
	[s] x1=1 & x2=10 -> 0.9:(x1'=1)&(x2'=10) + 0.1:(x1'=2)&(x2'=9)  ;
	[w] x1=1 & x2=10 -> 0.8:(x1'=2)&(x2'=9) + 0.1:(x1'=1)&(x2'=10) + 0.1:(x1'=5)&(x2'=6)  ;

	
	// OBSERVATION 2 - only go north,south, east or west

	//actual state 1
	[n] x1=2 & x2=1 -> 0.8:(x1'=2)&(x2'=1) + 0.1:(x1'=2)&(x2'=2) + 0.1:(x1'=0)&(x2'=0)  ;
	[s] x1=2 & x2=1 -> 0.8:(x1'=2)&(x2'=1) + 0.1:(x1'=2)&(x2'=2) + 0.1:(x1'=0)&(x2'=0)  ;
	[e] x1=2 & x2=1 -> 0.8:(x1'=2)&(x2'=2) + 0.2:(x1'=2)&(x2'=1)  ;
	[w] x1=2 & x2=1 -> 0.8:(x1'=0)&(x2'=0) + 0.2:(x1'=2)&(x2'=1)  ;

	//actual state 8
	[n] x1=2 & x2=8 -> 0.8:(x1'=2)&(x2'=8) + 0.1:(x1'=2)&(x2'=9) + 0.1:(x1'=0)&(x2'=7)  ;
	[s] x1=2 & x2=8 -> 0.8:(x1'=2)&(x2'=8) + 0.1:(x1'=2)&(x2'=9) + 0.1:(x1'=0)&(x2'=7)  ;
	[e] x1=2 & x2=8 -> 0.8:(x1'=2)&(x2'=9) + 0.2:(x1'=2)&(x2'=8)  ;
	[w] x1=2 & x2=8 -> 0.8:(x1'=0)&(x2'=7) + 0.2:(x1'=2)&(x2'=8)  ;

	//actual state 2
	[n] x1=2 & x2=2 -> 0.8:(x1'=2)&(x2'=2) + 0.1:(x1'=4)&(x2'=3) + 0.1:(x1'=2)&(x2'=1)  ;
	[s] x1=2 & x2=2 -> 0.8:(x1'=0)&(x2'=5) + 0.1:(x1'=4)&(x2'=3) + 0.1:(x1'=2)&(x2'=1)  ;
	[e] x1=2 & x2=2 -> 0.8:(x1'=4)&(x2'=3) + 0.1:(x1'=2)&(x2'=2) + 0.1:(x1'=0)&(x2'=5) ;
	[w] x1=2 & x2=2 -> 0.8:(x1'=2)&(x2'=1) + 0.1:(x1'=2)&(x2'=2) + 0.1:(x1'=0)&(x2'=5) ;

	//actual state 9
	[n] x1=2 & x2=9 -> 0.8:(x1'=0)&(x2'=5) + 0.1:(x1'=1)&(x2'=10) + 0.1:(x1'=2)&(x2'=8)  ;
	[s] x1=2 & x2=9 -> 0.8:(x1'=2)&(x2'=9) + 0.1:(x1'=1)&(x2'=10) + 0.1:(x1'=2)&(x2'=8)  ;
	[e] x1=2 & x2=9 -> 0.8:(x1'=1)&(x2'=10) + 0.1:(x1'=2)&(x2'=9) + 0.1:(x1'=0)&(x2'=5) ;
	[w] x1=2 & x2=9 -> 0.8:(x1'=2)&(x2'=8) + 0.1:(x1'=2)&(x2'=9) + 0.1:(x1'=0)&(x2'=5) ;

	// OBSERVATION 3 - only go north or south 

	//actual state 4
	[n] x1=3 & x2=4 -> 0.8:(x1'=0)&(x2'=0) + 0.2:(x1'=3)&(x2'=4)  ;
	[s] x1=3 & x2=4 -> 0.8:(x1'=0)&(x2'=7) + 0.2:(x1'=3)&(x2'=4) ;

	// OBSERVATION 4 - only exit

	//actual state 3
	[x] x1=4 & x2=3 -> (x1'=6)&(x2'=11); 
	
	// OBSERVATION 5 - only exit
	//actual state 6
	[x] x1=5 & x2=6 -> (x1'=6)&(x2'=11); 

	// OBSERVATION 6 - only loop
	//actual state "absorb state"
	[o] x1=6 &x2=11 -> (x1'=6); 
	

endmodule

init
	x1=0//&(x2=7)
	&(x2=0|x2=7)
	
	//x1=2//&(x2=8)
	//&(x2=1|x2=2|x2=8|x2=9)
endinit

// reward 
rewards "total_cost"
	
	// transition rewards
	[n]x2!=3 & x2!=6 : 2.04; 
	[s]x2!=3 & x2!=6 : 2.04; 
	[e]x2!=3 & x2!=6 : 2.04; 
	[w]x2!=3 & x2!=6 : 2.04; 
	
	[x]x2=3 : 1; 
	[x]x2=6 : 3; 

	//[i]true : 2;
endrewards

label "goal" = (x1=5);